# GFG POTD 25-01-23 : Type it!

# <a href="https://practice.geeksforgeeks.org/problems/95080eb9efbf7cc5cb4851ddf8d7946e3f212a49/1">Problem Link</a>

### Approach 1 : Get the maximum index of substring that can be appended according to rule 2.

```
class Solution {
  public:
    int minOperation(string s) {
        
        /* First will check maximum possible index
         of s upto which it can make equal
          substring to be concatenated*/
        int n=s.size();


        string str="";
        int j=n/2;
        int mx_i=-1;
        for(int i=0;i<n;)
        {
            if(i==0)
            {
                str+=s[i];
                i++;
            }
            else if(j>=0)
            {
                string s1=s.substr(0,i);
                string s2=s.substr(i,i);
                if(s1==s2)
                {
                    mx_i=max(mx_i,i);
                    str=s1+s2;
                    i=str.size();
                }
                else
                {
                    str+=s[i];
                    i++;
                }
            }
            else
            {
                str+=s[i];
                i++;
            }
            j--;
        }
        /*If no such index return s.length() 
        i.e each character is taken one by one.*/
        if(mx_i==-1)
        {
            return n;
        }
        //now simply calculate the ans using mx_i value
        int ans=1;
        ans+=mx_i;
        ans+=n-(2*mx_i);
        return ans;
    }
};
```
### Good test case to be checked  :
Input :
```
rtkrtkjrtkrtkjprepgg
```
Output :
```
14
```
### Time Complexity :O(N).
### Space Complexity :O(N).
