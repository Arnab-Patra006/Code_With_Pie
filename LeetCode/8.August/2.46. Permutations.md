# <a href="https://leetcode.com/problems/permutations/">46. Permutations</a>
## Let's try to understand how the next permutation algorithm work :

The nextPermutation method is used to find the next lexicographically greater permutation of the given array nums. It follows these steps:

+ Step 1: Find the first decreasing element in the array

Start from the end of the array and move towards the beginning.
Look for the first index i such that nums[i] < nums[i + 1].
If no such index is found, it means the array is in descending order, and there's no next permutation possible. Return false.

+ Step 2: Find the smallest element to the right of nums[i], but greater than nums[i]

Start from the end of the array and move towards the index i.
Look for the first index j such that nums[i] < nums[j].
Swap nums[i] and nums[j].

+ Step 3: Reverse the elements to the right of nums[i]

Reverse the elements in the array from index i + 1 to the end of the array.

+ Step 4: Return true, indicating that the next permutation has been found.

# Java Code Using similer approach :
```
public class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> ans = new ArrayList<>();
        Arrays.sort(nums);
        ans.add(convertArrayToList(nums));

        while (nextPermutation(nums)) {
            ans.add(convertArrayToList(nums));
        }

        return ans;
    }

    private List<Integer> convertArrayToList(int[] arr) {
        List<Integer> list = new ArrayList<>();
        for (int num : arr) {
            list.add(num);
        }
        return list;
    }

    private boolean nextPermutation(int[] nums) {
        int i = nums.length - 2;
        while (i >= 0 && nums[i] >= nums[i + 1]) {
            i--;
        }

        if (i >= 0) {
            int j = nums.length - 1;
            while (j >= 0 && nums[i] >= nums[j]) {
                j--;
            }
            swap(nums, i, j);
        }

        reverse(nums, i + 1, nums.length - 1);
        return i >= 0;
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }

    private void reverse(int[] nums, int i, int j) {
        while (i < j) {
            swap(nums, i, j);
            i++;
            j--;
        }
    }
}
```
# C++ Code (Using next_permutation)
```
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int>>ans;
        sort(nums.begin(),nums.end());
        ans.push_back(nums);
        while(next_permutation(nums.begin(),nums.end()))
        {
            ans.push_back(nums);
        }
        return ans;
    }
};
```
# C++ Code (Using prev_permutation)
```
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int>>ans;
        sort(nums.begin(),nums.end(),greater<int>());
        ans.push_back(nums);
        while(prev_permutation(nums.begin(),nums.end()))
        {
            ans.push_back(nums);
        }
        return ans;
    }
};
```